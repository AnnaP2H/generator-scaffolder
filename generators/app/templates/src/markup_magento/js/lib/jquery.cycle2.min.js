/*!
* jQuery Cycle2; build: v20131022
* http://jquery.malsup.com/cycle2/
* Copyright (c) 2013 M. Alsup; Dual licensed: MIT/GPL
*/
/*! core engine; version: 20131003 */
(function(e) {
  function t(e) {
    return (e || '').toLowerCase();
  }
  const i = '20131003';
  (e.fn.cycle = function(i) {
    let n;
    return this.length !== 0 || e.isReady
      ? this.each(function() {
          let n;

          let s;

          let o;

          let c;

          const r = e(this);

          let l = e.fn.cycle.log;
          if (!r.data('cycle.opts')) {
            (r.data('cycle-log') === !1 || (i && i.log === !1) || (s && s.log === !1)) && (l = e.noop),
              l('--c2 init--'),
              (n = r.data());
            for (const a in n)
              n.hasOwnProperty(a) &&
                /^cycle[A-Z]+/.test(a) &&
                ((c = n[a]),
                (o = a.match(/^cycle(.*)/)[1].replace(/^[A-Z]/, t)),
                l(`${o}:`, c, `(${typeof c})`),
                (n[o] = c));
            (s = e.extend({}, e.fn.cycle.defaults, n, i || {})),
              (s.timeoutId = 0),
              (s.paused = s.paused || !1),
              (s.container = r),
              (s._maxZ = s.maxZ),
              (s.API = e.extend({ _container: r }, e.fn.cycle.API)),
              (s.API.log = l),
              (s.API.trigger = function(e, t) {
                return s.container.trigger(e, t), s.API;
              }),
              r.data('cycle.opts', s),
              r.data('cycle.API', s.API),
              s.API.trigger('cycle-bootstrap', [s, s.API]),
              s.API.addInitialSlides(),
              s.API.preInitSlideshow(),
              s.slides.length && s.API.initSlideshow();
          }
        })
      : ((n = { s: this.selector, c: this.context }),
        e.fn.cycle.log('requeuing slideshow (dom not ready)'),
        e(() => {
          e(n.s, n.c).cycle(i);
        }),
        this);
  }),
    (e.fn.cycle.API = {
      opts() {
        return this._container.data('cycle.opts');
      },
      addInitialSlides() {
        const t = this.opts();

        let i = t.slides;
        (t.slideCount = 0),
          (t.slides = e()),
          (i = i.jquery ? i : t.container.find(i)),
          t.random && i.sort(() => Math.random() - 0.5),
          t.API.add(i);
      },
      preInitSlideshow() {
        const t = this.opts();
        t.API.trigger('cycle-pre-initialize', [t]);
        const i = e.fn.cycle.transitions[t.fx];
        i && e.isFunction(i.preInit) && i.preInit(t), (t._preInitialized = !0);
      },
      postInitSlideshow() {
        const t = this.opts();
        t.API.trigger('cycle-post-initialize', [t]);
        const i = e.fn.cycle.transitions[t.fx];
        i && e.isFunction(i.postInit) && i.postInit(t);
      },
      initSlideshow() {
        let t;

        const i = this.opts();

        let n = i.container;
        i.API.calcFirstSlide(),
          i.container.css('position') == 'static' && i.container.css('position', 'relative'),
          e(i.slides[i.currSlide])
            .css('opacity', 1)
            .show(),
          i.API.stackSlides(i.slides[i.currSlide], i.slides[i.nextSlide], !i.reverse),
          i.pauseOnHover &&
            (i.pauseOnHover !== !0 && (n = e(i.pauseOnHover)),
            n.hover(
              () => {
                i.API.pause(!0);
              },
              () => {
                i.API.resume(!0);
              }
            )),
          i.timeout && ((t = i.API.getSlideOpts(i.currSlide)), i.API.queueTransition(t, t.timeout + i.delay)),
          (i._initialized = !0),
          i.API.updateView(!0),
          i.API.trigger('cycle-initialized', [i]),
          i.API.postInitSlideshow();
      },
      pause(t) {
        const i = this.opts();

        const n = i.API.getSlideOpts();

        const s = i.hoverPaused || i.paused;
        t ? (i.hoverPaused = !0) : (i.paused = !0),
          s ||
            (i.container.addClass('cycle-paused'),
            i.API.trigger('cycle-paused', [i]).log('cycle-paused'),
            n.timeout &&
              (clearTimeout(i.timeoutId),
              (i.timeoutId = 0),
              (i._remainingTimeout -= e.now() - i._lastQueue),
              (i._remainingTimeout < 0 || isNaN(i._remainingTimeout)) && (i._remainingTimeout = void 0)));
      },
      resume(e) {
        const t = this.opts();

        const i = !t.hoverPaused && !t.paused;
        e ? (t.hoverPaused = !1) : (t.paused = !1),
          i ||
            (t.container.removeClass('cycle-paused'),
            t.slides.filter(':animated').length === 0 &&
              t.API.queueTransition(t.API.getSlideOpts(), t._remainingTimeout),
            t.API.trigger('cycle-resumed', [t, t._remainingTimeout]).log('cycle-resumed'));
      },
      add(t, i) {
        let n;

        const s = this.opts();

        const o = s.slideCount;

        let c = !1;
        e.type(t) == 'string' && (t = e.trim(t)),
          e(t).each(function() {
            let t;

            const n = e(this);
            i ? s.container.prepend(n) : s.container.append(n),
              s.slideCount++,
              (t = s.API.buildSlideOpts(n)),
              (s.slides = i ? e(n).add(s.slides) : s.slides.add(n)),
              s.API.initSlide(t, n, --s._maxZ),
              n.data('cycle.opts', t),
              s.API.trigger('cycle-slide-added', [s, t, n]);
          }),
          s.API.updateView(!0),
          (c = s._preInitialized && o < 2 && s.slideCount >= 1),
          c &&
            (s._initialized
              ? s.timeout &&
                ((n = s.slides.length), (s.nextSlide = s.reverse ? n - 1 : 1), s.timeoutId || s.API.queueTransition(s))
              : s.API.initSlideshow());
      },
      calcFirstSlide() {
        let e;

        const t = this.opts();
        (e = parseInt(t.startingSlide || 0, 10)),
          (e >= t.slides.length || e < 0) && (e = 0),
          (t.currSlide = e),
          t.reverse
            ? ((t.nextSlide = e - 1), t.nextSlide < 0 && (t.nextSlide = t.slides.length - 1))
            : ((t.nextSlide = e + 1), t.nextSlide == t.slides.length && (t.nextSlide = 0));
      },
      calcNextSlide() {
        let e;

        const t = this.opts();
        t.reverse
          ? ((e = t.nextSlide - 1 < 0),
            (t.nextSlide = e ? t.slideCount - 1 : t.nextSlide - 1),
            (t.currSlide = e ? 0 : t.nextSlide + 1))
          : ((e = t.nextSlide + 1 == t.slides.length),
            (t.nextSlide = e ? 0 : t.nextSlide + 1),
            (t.currSlide = e ? t.slides.length - 1 : t.nextSlide - 1));
      },
      calcTx(t, i) {
        let n;

        const s = t;
        return (
          i && s.manualFx && (n = e.fn.cycle.transitions[s.manualFx]),
          n || (n = e.fn.cycle.transitions[s.fx]),
          n || ((n = e.fn.cycle.transitions.fade), s.API.log(`Transition "${s.fx}" not found.  Using fade.`)),
          n
        );
      },
      prepareTx(e, t) {
        let i;

        let n;

        let s;

        let o;

        let c;

        const r = this.opts();
        return r.slideCount < 2
          ? ((r.timeoutId = 0), void 0)
          : (!e ||
              (r.busy && !r.manualTrump) ||
              (r.API.stopTransition(), (r.busy = !1), clearTimeout(r.timeoutId), (r.timeoutId = 0)),
            r.busy ||
              ((r.timeoutId !== 0 || e) &&
                ((n = r.slides[r.currSlide]),
                (s = r.slides[r.nextSlide]),
                (o = r.API.getSlideOpts(r.nextSlide)),
                (c = r.API.calcTx(o, e)),
                (r._tx = c),
                e && void 0 !== o.manualSpeed && (o.speed = o.manualSpeed),
                r.nextSlide != r.currSlide && (e || (!r.paused && !r.hoverPaused && r.timeout))
                  ? (r.API.trigger('cycle-before', [o, n, s, t]),
                    c.before && c.before(o, n, s, t),
                    (i = function() {
                      (r.busy = !1),
                        r.container.data('cycle.opts') &&
                          (c.after && c.after(o, n, s, t),
                          r.API.trigger('cycle-after', [o, n, s, t]),
                          r.API.queueTransition(o),
                          r.API.updateView(!0));
                    }),
                    (r.busy = !0),
                    c.transition ? c.transition(o, n, s, t, i) : r.API.doTransition(o, n, s, t, i),
                    r.API.calcNextSlide(),
                    r.API.updateView())
                  : r.API.queueTransition(o))),
            void 0);
      },
      doTransition(t, i, n, s, o) {
        const c = t;

        const r = e(i);

        const l = e(n);

        const a = function() {
          l.animate(c.animIn || { opacity: 1 }, c.speed, c.easeIn || c.easing, o);
        };
        l.css(c.cssBefore || {}),
          r.animate(c.animOut || {}, c.speed, c.easeOut || c.easing, () => {
            r.css(c.cssAfter || {}), c.sync || a();
          }),
          c.sync && a();
      },
      queueTransition(t, i) {
        const n = this.opts();

        const s = void 0 !== i ? i : t.timeout;
        return n.nextSlide === 0 && --n.loop === 0
          ? (n.API.log('terminating; loop=0'),
            (n.timeout = 0),
            s
              ? setTimeout(() => {
                  n.API.trigger('cycle-finished', [n]);
                }, s)
              : n.API.trigger('cycle-finished', [n]),
            (n.nextSlide = n.currSlide),
            void 0)
          : (s &&
              ((n._lastQueue = e.now()),
              void 0 === i && (n._remainingTimeout = t.timeout),
              n.paused ||
                n.hoverPaused ||
                (n.timeoutId = setTimeout(() => {
                  n.API.prepareTx(!1, !n.reverse);
                }, s))),
            void 0);
      },
      stopTransition() {
        const e = this.opts();
        e.slides.filter(':animated').length && (e.slides.stop(!1, !0), e.API.trigger('cycle-transition-stopped', [e])),
          e._tx && e._tx.stopTransition && e._tx.stopTransition(e);
      },
      advanceSlide(e) {
        const t = this.opts();
        return (
          clearTimeout(t.timeoutId),
          (t.timeoutId = 0),
          (t.nextSlide = t.currSlide + e),
          t.nextSlide < 0 ? (t.nextSlide = t.slides.length - 1) : t.nextSlide >= t.slides.length && (t.nextSlide = 0),
          t.API.prepareTx(!0, e >= 0),
          !1
        );
      },
      buildSlideOpts(i) {
        let n;

        let s;

        const o = this.opts();

        let c = i.data() || {};
        for (const r in c)
          c.hasOwnProperty(r) &&
            /^cycle[A-Z]+/.test(r) &&
            ((n = c[r]),
            (s = r.match(/^cycle(.*)/)[1].replace(/^[A-Z]/, t)),
            o.API.log(`[${o.slideCount - 1}]`, `${s}:`, n, `(${typeof n})`),
            (c[s] = n));
        (c = e.extend({}, e.fn.cycle.defaults, o, c)), (c.slideNum = o.slideCount);
        try {
          delete c.API, delete c.slideCount, delete c.currSlide, delete c.nextSlide, delete c.slides;
        } catch (l) {}
        return c;
      },
      getSlideOpts(t) {
        const i = this.opts();
        void 0 === t && (t = i.currSlide);
        const n = i.slides[t];

        const s = e(n).data('cycle.opts');
        return e.extend({}, i, s);
      },
      initSlide(t, i, n) {
        const s = this.opts();
        i.css(t.slideCss || {}),
          n > 0 && i.css('zIndex', n),
          isNaN(t.speed) && (t.speed = e.fx.speeds[t.speed] || e.fx.speeds._default),
          t.sync || (t.speed /= 2),
          i.addClass(s.slideClass);
      },
      updateView(e, t) {
        const i = this.opts();
        if (i._initialized) {
          const n = i.API.getSlideOpts();

          const s = i.slides[i.currSlide];
          (!e && t !== !0 && (i.API.trigger('cycle-update-view-before', [i, n, s]), i.updateView < 0)) ||
            (i.slideActiveClass &&
              i.slides
                .removeClass(i.slideActiveClass)
                .eq(i.currSlide)
                .addClass(i.slideActiveClass),
            e && i.hideNonActive && i.slides.filter(`:not(.${i.slideActiveClass})`).hide(),
            i.updateView === 0 &&
              setTimeout(() => {
                i.API.trigger('cycle-update-view', [i, n, s, e]);
              }, n.speed / (i.sync ? 2 : 1)),
            i.updateView !== 0 && i.API.trigger('cycle-update-view', [i, n, s, e]),
            e && i.API.trigger('cycle-update-view-after', [i, n, s]));
        }
      },
      getComponent(t) {
        const i = this.opts();

        const n = i[t];
        return typeof n === 'string' ? (/^\s*[\>|\+|~]/.test(n) ? i.container.find(n) : e(n)) : n.jquery ? n : e(n);
      },
      stackSlides(t, i, n) {
        const s = this.opts();
        t || ((t = s.slides[s.currSlide]), (i = s.slides[s.nextSlide]), (n = !s.reverse)), e(t).css('zIndex', s.maxZ);
        let o;

        let c = s.maxZ - 2;

        const r = s.slideCount;
        if (n) {
          for (o = s.currSlide + 1; r > o; o++) e(s.slides[o]).css('zIndex', c--);
          for (o = 0; s.currSlide > o; o++) e(s.slides[o]).css('zIndex', c--);
        } else {
          for (o = s.currSlide - 1; o >= 0; o--) e(s.slides[o]).css('zIndex', c--);
          for (o = r - 1; o > s.currSlide; o--) e(s.slides[o]).css('zIndex', c--);
        }
        e(i).css('zIndex', s.maxZ - 1);
      },
      getSlideIndex(e) {
        return this.opts().slides.index(e);
      }
    }),
    (e.fn.cycle.log = function() {
      window.console && console.log && console.log(`[cycle2] ${Array.prototype.join.call(arguments, ' ')}`);
    }),
    (e.fn.cycle.version = function() {
      return `Cycle2: ${i}`;
    }),
    (e.fn.cycle.transitions = {
      custom: {},
      none: {
        before(e, t, i, n) {
          e.API.stackSlides(i, t, n), (e.cssBefore = { opacity: 1, display: 'block' });
        }
      },
      fade: {
        before(t, i, n, s) {
          const o = t.API.getSlideOpts(t.nextSlide).slideCss || {};
          t.API.stackSlides(i, n, s),
            (t.cssBefore = e.extend(o, { opacity: 0, display: 'block' })),
            (t.animIn = { opacity: 1 }),
            (t.animOut = { opacity: 0 });
        }
      },
      fadeout: {
        before(t, i, n, s) {
          const o = t.API.getSlideOpts(t.nextSlide).slideCss || {};
          t.API.stackSlides(i, n, s),
            (t.cssBefore = e.extend(o, { opacity: 1, display: 'block' })),
            (t.animOut = { opacity: 0 });
        }
      },
      scrollHorz: {
        before(e, t, i, n) {
          e.API.stackSlides(t, i, n);
          const s = e.container.css('overflow', 'hidden').width();
          (e.cssBefore = { left: n ? s : -s, top: 0, opacity: 1, display: 'block' }),
            (e.cssAfter = { zIndex: e._maxZ - 2, left: 0 }),
            (e.animIn = { left: 0 }),
            (e.animOut = { left: n ? -s : s });
        }
      }
    }),
    (e.fn.cycle.defaults = {
      allowWrap: !0,
      autoSelector: '.cycle-slideshow[data-cycle-auto-init!=false]',
      delay: 0,
      easing: null,
      fx: 'fade',
      hideNonActive: !0,
      loop: 0,
      manualFx: void 0,
      manualSpeed: void 0,
      manualTrump: !0,
      maxZ: 100,
      pauseOnHover: !1,
      reverse: !1,
      slideActiveClass: 'cycle-slide-active',
      slideClass: 'cycle-slide',
      slideCss: { position: 'absolute', top: 0, left: 0 },
      slides: '> img',
      speed: 500,
      startingSlide: 0,
      sync: !0,
      timeout: 4e3,
      updateView: 0
    }),
    e(document).ready(() => {
      e(e.fn.cycle.defaults.autoSelector).cycle();
    });
})(jQuery) /*! Cycle2 autoheight plugin; Copyright (c) M.Alsup, 2012; version: 20130304 */,
  (function(e) {
    function t(t, n) {
      let s;

      let o;

      let c;

      const r = n.autoHeight;
      if (r == 'container') (o = e(n.slides[n.currSlide]).outerHeight()), n.container.height(o);
      else if (n._autoHeightRatio) n.container.height(n.container.width() / n._autoHeightRatio);
      else if (r === 'calc' || (e.type(r) == 'number' && r >= 0)) {
        if (((c = r === 'calc' ? i(t, n) : r >= n.slides.length ? 0 : r), c == n._sentinelIndex)) return;
        (n._sentinelIndex = c),
          n._sentinel && n._sentinel.remove(),
          (s = e(n.slides[c].cloneNode(!0))),
          s
            .removeAttr('id name rel')
            .find('[id],[name],[rel]')
            .removeAttr('id name rel'),
          s
            .css({ position: 'static', visibility: 'hidden', display: 'block' })
            .prependTo(n.container)
            .addClass('cycle-sentinel cycle-slide')
            .removeClass('cycle-slide-active'),
          s.find('*').css('visibility', 'hidden'),
          (n._sentinel = s);
      }
    }
    function i(t, i) {
      let n = 0;

      let s = -1;
      return (
        i.slides.each(function(t) {
          const i = e(this).height();
          i > s && ((s = i), (n = t));
        }),
        n
      );
    }
    function n(t, i, n, s) {
      const o = e(s).outerHeight();

      const c = i.sync ? i.speed / 2 : i.speed;
      i.container.animate({ height: o }, c);
    }
    function s(i, o) {
      o._autoHeightOnResize &&
        (e(window).off('resize orientationchange', o._autoHeightOnResize), (o._autoHeightOnResize = null)),
        o.container.off('cycle-slide-added cycle-slide-removed', t),
        o.container.off('cycle-destroyed', s),
        o.container.off('cycle-before', n),
        o._sentinel && (o._sentinel.remove(), (o._sentinel = null));
    }
    e.extend(e.fn.cycle.defaults, { autoHeight: 0 }),
      e(document).on('cycle-initialized', (i, o) => {
        function c() {
          t(i, o);
        }
        let r;

        const l = o.autoHeight;

        const a = e.type(l);

        let d = null;
        (a === 'string' || a === 'number') &&
          (o.container.on('cycle-slide-added cycle-slide-removed', t),
          o.container.on('cycle-destroyed', s),
          l == 'container'
            ? o.container.on('cycle-before', n)
            : a === 'string' &&
              /\d+\:\d+/.test(l) &&
              ((r = l.match(/(\d+)\:(\d+)/)), (r = r[1] / r[2]), (o._autoHeightRatio = r)),
          a !== 'number' &&
            ((o._autoHeightOnResize = function() {
              clearTimeout(d), (d = setTimeout(c, 50));
            }),
            e(window).on('resize orientationchange', o._autoHeightOnResize)),
          setTimeout(c, 30));
      });
  })(jQuery) /*! caption plugin for Cycle2;  version: 20130306 */,
  (function(e) {
    e.extend(e.fn.cycle.defaults, {
      caption: '> .cycle-caption',
      captionTemplate: '{{slideNum}} / {{slideCount}}',
      overlay: '> .cycle-overlay',
      overlayTemplate: '<div>{{title}}</div><div>{{desc}}</div>',
      captionModule: 'caption'
    }),
      e(document).on('cycle-update-view', (t, i, n, s) => {
        i.captionModule === 'caption' &&
          e.each(['caption', 'overlay'], function() {
            const e = this;

            const t = n[`${e}Template`];

            const o = i.API.getComponent(e);
            o.length && t ? (o.html(i.API.tmpl(t, n, i, s)), o.show()) : o.hide();
          });
      }),
      e(document).on('cycle-destroyed', (t, i) => {
        let n;
        e.each(['caption', 'overlay'], function() {
          const e = this;

          const t = i[`${e}Template`];
          i[e] && t && ((n = i.API.getComponent('caption')), n.empty());
        });
      });
  })(jQuery) /*! command plugin for Cycle2;  version: 20130707 */,
  (function(e) {
    const t = e.fn.cycle;
    (e.fn.cycle = function(i) {
      let n;

      let s;

      let o;

      const c = e.makeArray(arguments);
      return e.type(i) == 'number'
        ? this.cycle('goto', i)
        : e.type(i) == 'string'
          ? this.each(function() {
              let r;
              return (
                (n = i),
                (o = e(this).data('cycle.opts')),
                void 0 === o
                  ? (t.log(`slideshow must be initialized before sending commands; "${n}" ignored`), void 0)
                  : ((n = n == 'goto' ? 'jump' : n),
                    (s = o.API[n]),
                    e.isFunction(s)
                      ? ((r = e.makeArray(c)), r.shift(), s.apply(o.API, r))
                      : (t.log('unknown command: ', n), void 0))
              );
            })
          : t.apply(this, arguments);
    }),
      e.extend(e.fn.cycle, t),
      e.extend(t.API, {
        next() {
          const e = this.opts();
          if (!e.busy || e.manualTrump) {
            const t = e.reverse ? -1 : 1;
            (e.allowWrap === !1 && e.currSlide + t >= e.slideCount) ||
              (e.API.advanceSlide(t), e.API.trigger('cycle-next', [e]).log('cycle-next'));
          }
        },
        prev() {
          const e = this.opts();
          if (!e.busy || e.manualTrump) {
            const t = e.reverse ? 1 : -1;
            (e.allowWrap === !1 && e.currSlide + t < 0) ||
              (e.API.advanceSlide(t), e.API.trigger('cycle-prev', [e]).log('cycle-prev'));
          }
        },
        destroy() {
          this.stop();
          const t = this.opts();

          const i = e.isFunction(e._data) ? e._data : e.noop;
          clearTimeout(t.timeoutId),
            (t.timeoutId = 0),
            t.API.stop(),
            t.API.trigger('cycle-destroyed', [t]).log('cycle-destroyed'),
            t.container.removeData(),
            i(t.container[0], 'parsedAttrs', !1),
            t.retainStylesOnDestroy ||
              (t.container.removeAttr('style'), t.slides.removeAttr('style'), t.slides.removeClass(t.slideActiveClass)),
            t.slides.each(function() {
              e(this).removeData(), i(this, 'parsedAttrs', !1);
            });
        },
        jump(e) {
          let t;

          const i = this.opts();
          if (!i.busy || i.manualTrump) {
            const n = parseInt(e, 10);
            if (isNaN(n) || n < 0 || n >= i.slides.length) return i.API.log(`goto: invalid slide index: ${n}`), void 0;
            if (n == i.currSlide) return i.API.log('goto: skipping, already on slide', n), void 0;
            (i.nextSlide = n),
              clearTimeout(i.timeoutId),
              (i.timeoutId = 0),
              i.API.log('goto: ', n, ' (zero-index)'),
              (t = i.currSlide < i.nextSlide),
              i.API.prepareTx(!0, t);
          }
        },
        stop() {
          const t = this.opts();

          let i = t.container;
          clearTimeout(t.timeoutId),
            (t.timeoutId = 0),
            t.API.stopTransition(),
            t.pauseOnHover && (t.pauseOnHover !== !0 && (i = e(t.pauseOnHover)), i.off('mouseenter mouseleave')),
            t.API.trigger('cycle-stopped', [t]).log('cycle-stopped');
        },
        reinit() {
          const e = this.opts();
          e.API.destroy(), e.container.cycle();
        },
        remove(t) {
          for (var i, n, s = this.opts(), o = [], c = 1, r = 0; s.slides.length > r; r++)
            (i = s.slides[r]), r == t ? (n = i) : (o.push(i), (e(i).data('cycle.opts').slideNum = c), c++);
          n &&
            ((s.slides = e(o)),
            s.slideCount--,
            e(n).remove(),
            t == s.currSlide ? s.API.advanceSlide(1) : s.currSlide > t ? s.currSlide-- : s.currSlide++,
            s.API.trigger('cycle-slide-removed', [s, t, n]).log('cycle-slide-removed'),
            s.API.updateView());
        }
      }),
      e(document).on('click.cycle', '[data-cycle-cmd]', function(t) {
        t.preventDefault();
        const i = e(this);

        const n = i.data('cycle-cmd');

        const s = i.data('cycle-context') || '.cycle-slideshow';
        e(s).cycle(n, i.data('cycle-arg'));
      });
  })(jQuery) /*! hash plugin for Cycle2;  version: 20130905 */,
  (function(e) {
    function t(t, i) {
      let n;
      return t._hashFence
        ? ((t._hashFence = !1), void 0)
        : ((n = window.location.hash.substring(1)),
          t.slides.each(function(s) {
            if (e(this).data('cycle-hash') == n) {
              if (i === !0) t.startingSlide = s;
              else {
                const o = s > t.currSlide;
                (t.nextSlide = s), t.API.prepareTx(!0, o);
              }
              return !1;
            }
          }),
          void 0);
    }
    e(document).on('cycle-pre-initialize', (i, n) => {
      t(n, !0),
        (n._onHashChange = function() {
          t(n, !1);
        }),
        e(window).on('hashchange', n._onHashChange);
    }),
      e(document).on('cycle-update-view', (e, t, i) => {
        i.hash && `#${i.hash}` != window.location.hash && ((t._hashFence = !0), (window.location.hash = i.hash));
      }),
      e(document).on('cycle-destroyed', (t, i) => {
        i._onHashChange && e(window).off('hashchange', i._onHashChange);
      });
  })(jQuery) /*! loader plugin for Cycle2;  version: 20131020 */,
  (function(e) {
    e.extend(e.fn.cycle.defaults, { loader: !1 }),
      e(document).on('cycle-bootstrap', (t, i) => {
        function n(t, n) {
          function o(t) {
            let o;
            i.loader == 'wait'
              ? (r.push(t), a === 0 && (r.sort(c), s.apply(i.API, [r, n]), i.container.removeClass('cycle-loading')))
              : ((o = e(i.slides[i.currSlide])),
                s.apply(i.API, [t, n]),
                o.show(),
                i.container.removeClass('cycle-loading'));
          }
          function c(e, t) {
            return e.data('index') - t.data('index');
          }
          var r = [];
          if (e.type(t) == 'string') t = e.trim(t);
          else if (e.type(t) === 'array') for (let l = 0; t.length > l; l++) t[l] = e(t[l])[0];
          t = e(t);
          var a = t.length;
          a &&
            ((i.eventualSlideCount = i.slideCount + a),
            t
              .hide()
              .appendTo('body')
              .each(function(t) {
                function c() {
                  --l === 0 && (--a, o(d));
                }
                var l = 0;

                var d = e(this);

                let u = d.is('img') ? d : d.find('img');
                return (
                  d.data('index', t),
                  (u = u.filter(':not(.cycle-loader-ignore)').filter(':not([src=""])')),
                  u.length
                    ? ((l = u.length),
                      u.each(function() {
                        this.complete
                          ? c()
                          : e(this)
                              .load(() => {
                                c();
                              })
                              .error(function() {
                                --l === 0 &&
                                  (i.API.log('slide skipped; img not loaded:', this.src),
                                  --a === 0 && i.loader == 'wait' && s.apply(i.API, [r, n]));
                              });
                      }),
                      void 0)
                    : (--a, r.push(d), void 0)
                );
              }),
            a && i.container.addClass('cycle-loading'));
        }
        let s;
        i.loader && ((s = i.API.add), (i.API.add = n));
      });
  })(jQuery) /*! pager plugin for Cycle2;  version: 20130525 */,
  (function(e) {
    function t(t, i, n) {
      let s;

      const o = t.API.getComponent('pager');
      o.each(function() {
        const o = e(this);
        if (i.pagerTemplate) {
          const c = t.API.tmpl(i.pagerTemplate, i, t, n[0]);
          s = e(c).appendTo(o);
        } else s = o.children().eq(t.slideCount - 1);
        s.on(t.pagerEvent, e => {
          e.preventDefault(), t.API.page(o, e.currentTarget);
        });
      });
    }
    function i(e, t) {
      const i = this.opts();
      if (!i.busy || i.manualTrump) {
        const n = e.children().index(t);

        const s = n;

        const o = s > i.currSlide;
        i.currSlide != s &&
          ((i.nextSlide = s), i.API.prepareTx(!0, o), i.API.trigger('cycle-pager-activated', [i, e, t]));
      }
    }
    e.extend(e.fn.cycle.defaults, {
      pager: '> .cycle-pager',
      pagerActiveClass: 'cycle-pager-active',
      pagerEvent: 'click.cycle',
      pagerTemplate: '<span>&bull;</span>'
    }),
      e(document).on('cycle-bootstrap', (e, i, n) => {
        n.buildPagerLink = t;
      }),
      e(document).on('cycle-slide-added', (e, t, n, s) => {
        t.pager && (t.API.buildPagerLink(t, n, s), (t.API.page = i));
      }),
      e(document).on('cycle-slide-removed', (t, i, n) => {
        if (i.pager) {
          const s = i.API.getComponent('pager');
          s.each(function() {
            const t = e(this);
            e(t.children()[n]).remove();
          });
        }
      }),
      e(document).on('cycle-update-view', (t, i) => {
        let n;
        i.pager &&
          ((n = i.API.getComponent('pager')),
          n.each(function() {
            e(this)
              .children()
              .removeClass(i.pagerActiveClass)
              .eq(i.currSlide)
              .addClass(i.pagerActiveClass);
          }));
      }),
      e(document).on('cycle-destroyed', (e, t) => {
        const i = t.API.getComponent('pager');
        i && (i.children().off(t.pagerEvent), t.pagerTemplate && i.empty());
      });
  })(jQuery) /*! prevnext plugin for Cycle2;  version: 20130709 */,
  (function(e) {
    e.extend(e.fn.cycle.defaults, {
      next: '> .cycle-next',
      nextEvent: 'click.cycle',
      disabledClass: 'disabled',
      prev: '> .cycle-prev',
      prevEvent: 'click.cycle',
      swipe: !1
    }),
      e(document).on('cycle-initialized', (e, t) => {
        if (
          (t.API.getComponent('next').on(t.nextEvent, e => {
            e.preventDefault(), t.API.next();
          }),
          t.API.getComponent('prev').on(t.prevEvent, e => {
            e.preventDefault(), t.API.prev();
          }),
          t.swipe)
        ) {
          const i = t.swipeVert ? 'swipeUp.cycle' : 'swipeLeft.cycle swipeleft.cycle';

          const n = t.swipeVert ? 'swipeDown.cycle' : 'swipeRight.cycle swiperight.cycle';
          t.container.on(i, () => {
            t.API.next();
          }),
            t.container.on(n, () => {
              t.API.prev();
            });
        }
      }),
      e(document).on('cycle-update-view', (e, t) => {
        if (!t.allowWrap) {
          const i = t.disabledClass;

          const n = t.API.getComponent('next');

          const s = t.API.getComponent('prev');

          const o = t._prevBoundry || 0;

          const c = void 0 !== t._nextBoundry ? t._nextBoundry : t.slideCount - 1;
          t.currSlide == c ? n.addClass(i).prop('disabled', !0) : n.removeClass(i).prop('disabled', !1),
            t.currSlide === o ? s.addClass(i).prop('disabled', !0) : s.removeClass(i).prop('disabled', !1);
        }
      }),
      e(document).on('cycle-destroyed', (e, t) => {
        t.API.getComponent('prev').off(t.nextEvent),
          t.API.getComponent('next').off(t.prevEvent),
          t.container.off(
            'swipeleft.cycle swiperight.cycle swipeLeft.cycle swipeRight.cycle swipeUp.cycle swipeDown.cycle'
          );
      });
  })(jQuery) /*! progressive loader plugin for Cycle2;  version: 20130315 */,
  (function(e) {
    e.extend(e.fn.cycle.defaults, { progressive: !1 }),
      e(document).on('cycle-pre-initialize', (t, i) => {
        if (i.progressive) {
          let n;

          let s;

          const o = i.API;

          const c = o.next;

          const r = o.prev;

          const l = o.prepareTx;

          const a = e.type(i.progressive);
          if (a == 'array') n = i.progressive;
          else if (e.isFunction(i.progressive)) n = i.progressive(i);
          else if (a == 'string') {
            if (((s = e(i.progressive)), (n = e.trim(s.html())), !n)) return;
            if (/^(\[)/.test(n))
              try {
                n = e.parseJSON(n);
              } catch (d) {
                return o.log('error parsing progressive slides', d), void 0;
              }
            else (n = n.split(RegExp(s.data('cycle-split') || '\n'))), n[n.length - 1] || n.pop();
          }
          l &&
            (o.prepareTx = function(e, t) {
              let s;
              let o;
              return e || n.length === 0
                ? (l.apply(i.API, [e, t]), void 0)
                : (t && i.currSlide == i.slideCount - 1
                    ? ((o = n[0]),
                      (n = n.slice(1)),
                      i.container.one('cycle-slide-added', (e, t) => {
                        setTimeout(() => {
                          t.API.advanceSlide(1);
                        }, 50);
                      }),
                      i.API.add(o))
                    : t || i.currSlide !== 0
                      ? l.apply(i.API, [e, t])
                      : ((s = n.length - 1),
                        (o = n[s]),
                        (n = n.slice(0, s)),
                        i.container.one('cycle-slide-added', (e, t) => {
                          setTimeout(() => {
                            (t.currSlide = 1), t.API.advanceSlide(-1);
                          }, 50);
                        }),
                        i.API.add(o, !0)),
                  void 0);
            }),
            c &&
              (o.next = function() {
                const e = this.opts();
                if (n.length && e.currSlide == e.slideCount - 1) {
                  const t = n[0];
                  (n = n.slice(1)),
                    e.container.one('cycle-slide-added', (e, t) => {
                      c.apply(t.API), t.container.removeClass('cycle-loading');
                    }),
                    e.container.addClass('cycle-loading'),
                    e.API.add(t);
                } else c.apply(e.API);
              }),
            r &&
              (o.prev = function() {
                const e = this.opts();
                if (n.length && e.currSlide === 0) {
                  const t = n.length - 1;

                  const i = n[t];
                  (n = n.slice(0, t)),
                    e.container.one('cycle-slide-added', (e, t) => {
                      (t.currSlide = 1), t.API.advanceSlide(-1), t.container.removeClass('cycle-loading');
                    }),
                    e.container.addClass('cycle-loading'),
                    e.API.add(i, !0);
                } else r.apply(e.API);
              });
        }
      });
  })(jQuery) /*! tmpl plugin for Cycle2;  version: 20121227 */,
  (function(e) {
    e.extend(e.fn.cycle.defaults, { tmplRegex: '{{((.)?.*?)}}' }),
      e.extend(e.fn.cycle.API, {
        tmpl(t, i) {
          const n = RegExp(i.tmplRegex || e.fn.cycle.defaults.tmplRegex, 'g');

          const s = e.makeArray(arguments);
          return (
            s.shift(),
            t.replace(n, (t, i) => {
              let n;

              let o;

              let c;

              let r;

              const l = i.split('.');
              for (n = 0; s.length > n; n++)
                if ((c = s[n])) {
                  if (l.length > 1) for (r = c, o = 0; l.length > o; o++) (c = r), (r = r[l[o]] || i);
                  else r = c[i];
                  if (e.isFunction(r)) return r.apply(c, s);
                  if (void 0 !== r && r !== null && r != i) return r;
                }
              return i;
            })
          );
        }
      });
  })(jQuery);
